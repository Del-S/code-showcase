#!/usr/bin/env bash

# This script creates files containing logging lines of code with message that is logged in them. It
# is used mainly for Security reasons to allow audit of logs used in the app. For now it tracks
# public logs which have INFO, WARN or ERROR level. Debug logs are not listed.

# How it works: searches through all *.kt files for logging lines containing "logInfo", "logWarn"
# or "logError" using regex. Each logging level is saved into a specific file. After that is done
# each of the resulting logs is checked for variables inside of the text which are identified by
# "$" inside of quotes. It can be either "$variable" or "${variable}". These are potential security
# risk and need to be checked before every release.

# Options (variables):
#   TARGET_DIR - destination where list files will be created
#
# TEST VALUES:
# TARGET_DIR="./build/log-lists"

variableLogFile="$TARGET_DIR/logVariables.txt"
errorMessageLogFile="$TARGET_DIR/logErrorMessage.txt"

# Sets error and pipeline fail only for non CSOB CI/CD. We do not want to crash the build due to
# logging report. It also modifies which commands should run since CSOB CI/CD runs on macOS with
# additional GNU features separated (gsed/ggrep).
grep_command=grep
sed_command=sed
if [[ $CSOB_CI == "true" || "$(uname)" == "Darwin" ]]; then
    echo "Pipeline failing disabled"
    echo "Forcing GNU commands"
    grep_command=ggrep
    sed_command=gsed
else
    echo "Enabling pipeline failing"
    set -euo pipefail
fi

# Initializes variables for this script. Makes sure target directory exists and sets values to
# logLevels variable to make sure all required log levels are checked.
init() {
    echo "Initializing"
    if [ ! -d $TARGET_DIR ]; then
        echo "Creating target dir"
        mkdir -p $TARGET_DIR
    fi
    logLevels["logInfo"]="$TARGET_DIR/logInfo.txt"
    logLevels["logWarn"]="$TARGET_DIR/logWarn.txt"
    logLevels["logError"]="$TARGET_DIR/logError.txt"
}

# Generates log list files for every log level defined in logLevels map variable. Every kotlin file
# searched using Regex, each log is then formatted to be on one line and each of them is saved to
# specific log file also defined in logLevels map.
function generateLogListFiles() {
    for logLevel in "${!logLevels[@]}"; do
        logFile=${logLevels[$logLevel]}
        echo "Generating log file $logFile for log level $logLevel"
        $grep_command -zhPro "$logLevel[ ]?[{(](\n?|.)+[\"](\n?|.)+[\"](\n?|.)+([)}][ ]?\n)" . --include=*.kt |
            $sed_command -z 's/\n//g' |
            $sed_command 's/  //g' |
            $sed_command 's/\x0//g' |
            $sed_command 's/'$logLevel'/\n&/g' >$logFile
    done
    echo "Log list files generated"
}

# Generates log list file for error message. Every kotlin file is searched using Regex, each log is
# then formatted to be on one line and each of them is saved to specific log file also defined in
# errorMessageLogFile variable.
function generateErrorMessageListFile() {
    echo "Generating log file $errorMessageLogFile log error message"
    $grep_command -zhPro "errorMessage[ ]?[=][ ]?[{](\n?|.)+([\"](\n?|.)+[\"]|null)(\n?|.)+([}](\n|,|\))+)" . --include=*.kt |
        $sed_command -z 's/\n//g' |
        $sed_command 's/  //g' |
        $sed_command 's/\x0//g' |
        $sed_command 's/errorMessage/\n&/g' >$errorMessageLogFile
    echo "Error log list file generated"
}

# Generates log file containing logs with a variables in a message. Takes each file previously
# generated by this script and searches every line for "$" using regex which represents variable in
# the message. Each found line is appended to a file defined in variableLogFile.
function generateVariableLogListFile() {
    echo "Generating Variable log list file"
    >$variableLogFile
    for logLevel in "${!logLevels[@]}"; do
        logFile=${logLevels[$logLevel]}
        echo "Searching $logFile for variables"
        $grep_command -r ".*\$.*" $logFile >>$variableLogFile
    done
    echo "Searching $errorMessageLogFile for variables"
    $grep_command -r ".*\$.*" $errorMessageLogFile >>$variableLogFile
    echo "Variable log list file generated"
}

echo "Log report script started"
declare -A logLevels
init
generateLogListFiles
generateErrorMessageListFile
generateVariableLogListFile
echo "Log report script finished"
